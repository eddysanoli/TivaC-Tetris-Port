#ifndef _CONSTANTES_H_
#define _CONSTANTES_H_


// Matrices de "Game Area"

  byte P1_Buffer [][12] = {
  // 0  1  2  3  4  5  6  7  8  9 10 11
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 0:  Fila de Muerte
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 1:  Techo del Game Area
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 2:  Fila 1
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 3:  Fila 2
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 4:  Fila 3
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 5:  Fila 4
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 6:  Fila 5
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 7:  Fila 6
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 8:  Fila 7
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 9:  Fila 8
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 10: Fila 9
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 11: Fila 10
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 12: Fila 11
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 13: Fila 12
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 14: Fila 13
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 15: Fila 14
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 16: Fila 15
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 17: Fila 16
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 18: Fila 17
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 19: Fila 18
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 20: Fila 19
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 21: Fila 20
    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}      // 22: Piso del Game Area
  // 0  1  2  3  4  5  6  7  8  9 10 11
  };
  
  byte P1_GameArea [][12] = {
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 0:  Fila de Muerte
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 1:  Fila donde "Spawnean" los bloques. Techo del Game Area
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 2:  Fila 1
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 3:  Fila 2
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 4:  Fila 3
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 5:  Fila 4
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 6:  Fila 5
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 7:  Fila 6
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 8:  Fila 7
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 9:  Fila 8
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 10: Fila 9
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 11: Fila 10
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 12: Fila 11
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 13: Fila 12
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 14: Fila 13
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 15: Fila 14
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 16: Fila 15
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 17: Fila 16
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 18: Fila 17
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 19: Fila 18
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 20: Fila 19
    {5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5},     // 21: Fila 20
    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}      // 22: Piso del Game Area
  };

  byte TetrominoActivo[][4] = {
    {0 , 0 , 0 , 0},
    {0 , 0 , 0 , 0},
    {0 , 0 , 0 , 0},
    {0 , 0 , 0 , 0}
  };

// Matrices para cada tetromino. Creadas en base al sistema de rotación explicado en:
// https://tetris.fandom.com/wiki/Nintendo_Rotation_System. Como se puede observar en
// esta imagen, cada tetromino utiliza un tipo de bloque diferente. En total existen
// 3 variaciones de bloque, de aquí los números almacenados (Distintos de 0) en las matrices

  // Tetromino: I
  int I[][4] = {
    {0 , 0 , 0 , 0},
    {0 , 0 , 0 , 0},
    {3 , 3 , 3 , 3},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: J
  int J[][4] = {
    {0 , 0 , 0 , 0},
    {2 , 2 , 2 , 0},
    {0 , 0 , 2 , 0},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: L
  int L[][4] = {
    {0 , 0 , 0 , 0},
    {1 , 1 , 1 , 0},
    {1 , 0 , 0 , 0},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: O
  int O[][4] = {
    {3 , 3 , 0 , 0},
    {3 , 3 , 0 , 0},
    {0 , 0 , 0 , 0},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: S
  int S[][4] = {
    {0 , 0 , 0 , 0},
    {0 , 2 , 2 , 0},
    {2 , 2 , 0 , 0},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: Z
  int Z[][4] = {
    {0 , 0 , 0 , 0},
    {1 , 1 , 0 , 0},
    {0 , 1 , 1 , 0},
    {0 , 0 , 0 , 0}
  };
  // Tetromino: T
  int T[][4] = {
    {0 , 0 , 0 , 0},
    {3 , 3 , 3 , 0},
    {0 , 3 , 0 , 0},
    {0 , 0 , 0 , 0}
  };

// Paleta de Colores para Cada Nivel del Juego
// NOTA: Para convertir colores al código requerido por FillRect() se debe tomar los valores
// RGB del color deseado y se introducen a la fórmula: (R/8)*2048 + (G/4)*32 + (B/8)
// El decimal obtenido se convierte a hexadecimal y se coloca en la función. Si no se desea hacer
// esto utiizar el siguiente link: http://www.barth-dev.de/online/rgb565-color-picker/#
  const int Palette[][2] = {
    {0x02df, 0x3dff},     // Nivel 0
    {0x0540, 0xbfc3},     // Nivel 1
    {0xd819, 0xfbdf},     // Nivel 2
    {0x02df, 0x5eca},     // Nivel 3
    {0xe00b, 0x5fd3},     // Nivel 4
    {0x5fd3, 0x6c5f},     // Nivel 5
    {0xf9c0, 0x7bef},     // Nivel 6
    {0x6a3f, 0xa804},     // Nivel 7
    {0x02df, 0xf9c0},     // Nivel 8
    {0xf9c0, 0xfd08},     // Nivel 9
  };

// Posiciones de Sprites de Tetrominos Grises en el borde
// de la pantalla de inicio.
  
  // Marco Superior
  const byte MarcoSup[][40] = {
    {7, 0, 13, 5, 7, 6, 0, 5, 15, 14, 5, 7, 0, 15, 8, 15, 0, 7, 6, 14, 11, 10, 9, 19, 4, 9, 9, 7, 6, 2, 5, 9, 7, 6, 2, 7, 6, 6, 4, 5},
    {7, 6, 0, 7, 16, 4, 15, 4, 11, 10, 7, 6, 2, 9, 9, 9, 9, 15, 14, 9, 9, 7, 0, 5, 13, 5, 1, 4, 12, 5, 13, 1, 4, 13, 5, 12, 12, 15, 14, 13},
    {3, 6, 4, 13, 5, 7, 0, 12, 7, 6, 6, 4, 5, 5, 9, 7, 17, 11, 10, 3, 0, 12, 12, 7, 18, 4, 12, 12, 12, 7, 18, 4, 3, 0, 12, 12, 12, 11, 10, 19},
    {5, 13, 7, 18, 4, 12, 12, 12, 12, 12, 12, 12, 12, 7, 0, 12, 5, 12, 12, 5, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 5, 12, 12, 12, 12, 12, 13, 5}
  };

  // Marco Inferior
  const byte MarcoInf[][37] = {
    {7, 16, 4, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,     12, 12, 12, 12, 12, 12, 13, 12, 12, 7, 6, 0},
    {12, 5, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12,    12, 12, 12, 13, 12, 12, 9, 12, 12, 12, 15, 14},
    {12, 12, 12, 7, 2, 12, 12, 12, 12, 13, 7, 6, 2, 12, 3, 8, 3, 4, 13, 12, 13, 13, 7, 17, 3,              6, 4, 12, 1, 14, 12, 9, 3, 6, 4, 11, 10},
    {4, 12, 13, 13, 1, 4, 7, 16, 4, 9, 7, 2, 5, 13, 9, 7, 0, 7, 17, 3, 0, 1, 2, 5, 5,                      7, 6, 6, 4, 5, 13, 5, 5, 13, 7, 2, 7}
  };

  // Marco Izquierdo
  const byte MarcoIzq[][3] = {
    {3, 0, 12},
    {5, 12, 12},
    {3, 8, 12},
    {9, 12, 12},
    {9, 12, 12},
    {3, 6, 4},
    {5, 13, 12},
    {7, 16, 4},
    {4, 5, 12},
    {15, 14, 12},
    {11, 10, 12},
    {3, 8, 12},
    {9, 13, 12},
    {5, 1, 14},
    {4, 13, 5},
    {13, 19, 4},
    {9, 5, 12},
    {1, 4, 12},
    {6, 6, 4},
    {14, 13, 12},
    {10, 9, 12},
    {2, 9, 12},
    {9, 5, 12},
    {5, 3, 4},
    {7, 0, 13},
    {15, 14, 19}
  };  

  // Marco Derecho
  const byte MarcoDer[][4] = {
    {12, 12, 1, 2},
    {12, 12, 13, 5},
    {12, 12, 9, 13},
    {12, 12, 9, 9},
    {12, 13, 5, 9},
    {12, 1, 2, 5},
    {12, 12, 5, 13},
    {12, 12, 13, 19},
    {12, 12, 9, 5},
    {12, 12, 1, 4},
    {12, 7, 6, 2},
    {7, 16, 4, 5},
    {12, 5, 7, 2},
    {12, 12, 13, 9},
    {12, 3, 0, 5},
    {12, 5, 3, 4},
    {12, 12, 9, 7},
    {12, 12, 5, 13},
    {12, 12, 3, 0},
    {12, 12, 5, 13},
    {13, 7, 6, 0},
    {1, 6, 4, 13}
  };  
  

#endif
/*********************************************************************************************************
  END FILE
*********************************************************************************************************/
